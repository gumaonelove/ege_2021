def ans_1(E):
    '''Может ли данная матрица быть матрицей смежности
        простого неорентированного графа'''
    N = len(E)
    for i in range(N): # stroka
        if E[i][i] != 0: return "NO"
        for j in range(N): # stolb
            if E[i][j] != E[j][i]: return "NO"
    return "YES"

def ans_2(E):
    '''По заданой матрице смежности неорентированого графа определите,
        содержит ли он петли '''
    N = len(E)
    for i in range(N):  # stroka
        if E[i][i] != 0: return "YES"
    return "NO"

def ans_3(N):
    '''Простой не ореентированый граф задан матрицей смежности,
        Найти количество вершин на графе'''
    return N

def ans_4(E):
    '''Простой не ореентированый граф задан матрицей смежности,
        Найти количество ребер на графе'''
    N = len(E)
    ribs = 0
    for i in range(N):
        for j in range(N):
            if E[i][j] == 1: ribs += 1
    return ribs

def ans_5(E):
    '''Простой не ореентированый граф задан матрицей смежности,
        выведите его представление в виде списка ребер'''
    ribs = [] # Список ребер, структура: [(), ()] пара ребер кортеж
    N = len(E)
    for i in range(N):
        for j in range(i, N):
            if E[i][j]==1:
                ribs.append((i+1, j+1))
    return list(ribs)

def ans_6(E, n):
    '''Простой неориентированный граф задан списком ребер,
        выведете его представление в виде матрицы смежности'''
    A = []
    for i in range(n): A.append([0]*n)
    for i in range(n):
        x = E[i*2]-1
        y = E[2*i+1]-1
        A[x][y] , A[y][x] = 1, 1
    return A

def ans_7(E):
    '''Ореентированый граф задан матрицей смежности,
            выведите его представление в виде списка ребер'''
    ribs = []  # Список ребер, структура: [(), ()] пара ребер кортеж
    N = len(E)
    for i in range(N):
        for j in range(N):
            if E[i][j] == 1:
                ribs.append((i + 1, j + 1))
    return list(ribs)

def ans_8(E, n, m):
    '''ориентированный граф задан списком ребер,
        выведете его представление в виде матрицы смежности'''
    A = []
    for _ in range(n): A.append([0]*n)
    for i in range(m):
        x = E[i*2]-1
        y = E[2*i+1]-1
        A[x][y] = 1
    return A

def ans_9(E, N):
    '''Помогаем Васе развернуть граф'''
    B = [] # индекс вершина, вложмасив - куда из этой вершины можно пройти
    for _ in range(N): B.append([])
    for i in E: B[i[1]-1].append(i[0])
    return B

def ans_10(E, m):
    """Содержит ли неориентированнный граф параллельные ребра"""
    for i in range(m):
        for j in range(i+1, m): #FIX ME
            if (E[i*2]==E[j*2] and E[i*2+1]==E[j*2+1]) or \
                    (E[i*2]==E[j*2+1] and  E[i*2+1]==E[j*2]):
                return "YES"
    return "NO"

def ans_11(E, m):
    """Содержит ли ориентированнный граф параллельные ребра"""
    for i in range(m):
        for j in range(i + 1, m):  # FIX ME
            if E[i * 2] == E[j * 2] and E[i * 2 + 1] == E[j * 2 + 1]:
                return "YES"
    return "NO"

def ans_12(E):
    '''Неориентированый граф задан матрицей смежности, найдите степени всех вершин графа'''
    N = len(E)
    ans = ''
    for i in range(N):
        ans += str(sum(E[i])) + ' '
    return ans

def ans_13(E, n):
    '''Неориентированый граф задан списком ребер, найдите степени всех вершин графа'''
    A = [0]*(n+1) # Массив степеней ребер индекс = само ребро, значение = его степень
    # счет начинается с 1, 0 число для удобства взаимодействия
    for i in range(n):
        x, y = E[i*2], E[i*2+1] # можно без переменных х, у, прсто я подумал что так пизже смотрится
        A[x] += 1; A[y] +=1
    return A[1:]

def ans_14(E):
    '''Ореентированый граф задан матрицей смежности,
            найдите полустепени захода и полустепени исхода всех вершин графа'''

    n = len(E)
    A = []
    # массив полустепенией заода и исхода структора: [[], []], индекс = номер вершины,
    # 0 элемент кортежа - стпенеь захода, 1 элемент кортежа - степень исхода

    for _ in range(n): A.append([0, 0])
    for i in range(n): # строчка
        for j in range(n): # столбик
            A[i][1] += E[i][j]
            A[i][0] += E[j][i]
    return A

def ans_15(E, n, m):
    '''Неориентированый граф задан списком ребер, найдите степени всех вершин графа
        выведете сначала полустепень захода, потом полоустепень исхода'''
    A = []
    # массив полустепенией заода и исхода структора: [[], []], индекс = номер вершины,
    # 0 элемент кортежа - стпенеь захода, 1 элемент кортежа - степень исхода
    for _ in range(n): A.append([0, 0])
    for i in range(m):
        A[E[2*i]-1][1] += 1
        A[E[2 * i+1] - 1][0] += 1
    return A

def ans_16(E):
    '''Напомним, что вершина ориентированого графа называется
    - истоком, если в нее не входит ни одно ребро;
    - стоком, если из нее не выходит ни одного ребра

    Ориентированный граф задан матрицей смежности, Найдите все вершины графа, которые
    являеются истоками, и все его вершины которые называются стоками'''
    n = len(E)
    istok = []
    stok = []
    flag = 1
    # stok:
    for i in range(n): # stroka
        if sum(E[i]) == 0: stok.append(i+1)

    #istok
    for j in range(n):
        for i in range(n):
            if E[i][j] == 0: flag *= 1
            else: flag *= 0
        if flag == 1:
            istok.append(j+1)
        flag = 1

    return [(len(istok), istok), (len(stok), stok)]

def ans_17(E, n, m):
    '''Неориентрированный граф называется регулярным, если все его вершины имеют
    одинакувую степень
    для заданного списка ребер, проверьте, является ои он регулярным'''
    A = [0]*n # массив вершин и кол-ва их вхождений
    # структура: индекс = номер вершины, значение = степень вхождений
    for i in range(m):
        A[E[2*i+1]-1] += 1
        A[E[2 * i] - 1] += 1
    if float(A[0]) == sum(A)/n: return "YES"
    return "NO"

def ans_18(E, n, m):
    '''Неориентированный граф с кратными ребрами называется полным, если любая
    пара его различных вершин соеденина хотябы одним ребром,
    для заданного графа проверьте евляется ли он полным'''
    if n*(n-1)//2 == m: return "YES"
    return "NO"

def go_to_matrica(E, n, m):
    '''Получим список ребер, вернем матрицу смежности для ориентированого графа'''
    # осторожно говно код
    A = []  # Массив ребер, индекс= вершина от, влож массив = куда идет
    for _ in range(n): A.append([0] * n)
    for i in range(m):
        A[E[i * 2] - 1][E[i * 2 + 1] - 1] = 1
    return A

def ans_19(E, n, m):
    '''Ориентированный граф называется полуполным, если между любой парой его
    различных вершин есть хотябы одно ребро
    для заданного списком ребер графа определите является ли он полуполным'''
    # осторожно говно код
    A = go_to_matrica(E, n, m) # Массив ребер, индекс= вершина от, влож массив = куда идет

    for i in range(n):
        for j in range(n):
            if i == j:
                pass
            elif A[i][j] != 1 and A[j][i] != 1: return "NO"
    return "YES"

def ans_20(E, n, m):
    '''Ориентированный граф называется туриром, если между любой парой его различных
    вершин существует ровно одно ребро, для заданного списка ребер определите
    является ли данный граф турниром'''

    for i in range(m): # проверили есть ли между двумя вершинами 2 и более ребра
        for j in range(i+1, m):
            if (E[2*i] == E[2*j] and E[2*i+1] == E[2*j+1]) or \
                (E[2*i+1] == E[2*j] and E[2*i] == E[2*j+1]):
                return "NO"
    return ans_19(E, n, m)

def ans_21(E, V, n, m):
    """Граф называется транзитивным, если всегда из того, что вершины u w
     соеденены ребром и вершины v w соеденены ребром следует, что вершины u w
     соеденены ребром
     Проверьте, что является ли заданный граф транзитивным"""
    flag = 1
    for i in range(m):
        for j in range(i+1, m):
            x1, x2 = E[0][i], E[1][i]
            y1, y2 = E[0][j], E[1][j]
            if x1 == y1 and ( ((x2 in E[0]) and (y2 in E[1])) or ((x2 in E[1]) and (y2 in E[0]))): flag *= 1
            elif x2 == y2 and ( ((x1 in E[0]) and (y1 in E[1])) or ((x1 in E[1]) and (y1 in E[0]))): flag *= 1
            elif x1 == y2 and ( ((x2 in E[0]) and (y1 in E[1])) or ((x2 in E[1]) and (y1 in E[0]))): flag *= 1
            elif x2 == y1 and ( ((x1 in E[0]) and (y2 in E[1])) or ((x1 in E[1]) and (y2 in E[0]))): flag *= 1
            else: flag *= 0
            if flag == 0: return "NO"
        flag = 1
    if flag == 1: return "YES"
    else: return "NO"

def go_list_verbs(E):
    '''Матрица -> Список вершин (ориентированный)'''
    n = len(E)
    A = []
    for j in range(n):
        for i in range(n):
            if E[i][j] == 1:
                A.append((i, j))
    return A


def ans_22(E):
    '''Ориентированный граф называется транзитивным, если для любых
    трех различных вершин u,v,w из того, что из u в вершину v ведет ребро и из
    вершины v в вершину w ведет ребро, следует что из вершины u в вершину w
    ведет ребро
    Проверьте заданный ориентированный граф является ли транзитивным'''

    A = go_list_verbs(E)
    m = len(A)
    print(A)
    for i in range(m):
        for j in range(i+1, m):
            x1, x2 = A[i][0], A[i][1]
            y1, y2 = A[j][0], A[j][1]
            if x2 == y1 and ((x1, y2) in A):
                print((x1, x2), (y1, y2))
                return "YES"

    return "NO"
































